Adding Two‑Factor Authentication (2FA) to a Laravel API (Laragear + Sanctum)

I recently wired up Two‑Factor Authentication (2FA) for the Profresh API. There are a few ways to do 2FA in Laravel, but I chose the Laragear 2FA package because it’s simple, well‑documented, and plays nicely with Sanctum.

This post shows exactly how I implemented it on the backend: endpoints to enable/confirm/disable 2FA, recovery codes, and a secure login flow that requires the one‑time code when 2FA is enabled.

Who this is for
- You’re building a JSON API with Laravel 10 and Sanctum.
- You’re comfortable with basic auth flows and Form Requests.
- You want a clean, minimal 2FA setup without re‑inventing OTP math.

What we’ll build
1) Turn on 2FA for a user (generate secret + QR, confirm with a 6‑digit code, show recovery codes)
2) Require 2FA on login if the user has it enabled (short‑lived session handoff, then issue a Sanctum token)

Package
- Laragear 2FA (v2 for Laravel 10). For Laravel 11, use the v3 docs — the code is very similar.

---

1) Enable 2FA for a user

First, the user opts‑in. We generate a secret, return a QR, and mark the process in progress. The user scans the QR in Google Authenticator/Authy/etc. and then confirms with a 6‑digit code.

Controller: prepare

    public function prepareTwoFactor(PrepareTwoFactorRequest $request): \Illuminate\Http\JsonResponse
    {
        $user = $request->user();
        $secret = $user->createTwoFactorAuth();

        return response()->json([
            'qr_code' => $secret->toQr(),
            'uri'     => $secret->toUri(),
            'string'  => $secret->toString(),
            'status'  => \App\Enums\TwoFactorStatus::IN_PROGRESS->value,
        ], 200);
    }

The request class (PrepareTwoFactorRequest) does the basics: ensure the user enters their current password and that 2FA isn’t already enabled.

What this does
- Creates a pending 2FA secret for the current user.
- Returns a QR image (base64), an otpauth URI, and the raw secret string so the client can show a QR or let the user paste the code into their authenticator app.
- Marks the process as in_progress so the UI can guide the user to the next step.

Example request/response
- Request: POST /api/twofactor/setup with a valid session/token and the user’s current password (validated in the FormRequest).
- Response:

        {
            "qr_code": "data:image/svg+xml;base64,....",
            "uri": "otpauth://totp/Profresh:john@example.com?...",
            "string": "JBSWY3DPEHPK3PXP",
            "status": "in_progress"
        }

Controller: confirm

    public function confirmTwoFactor(ConfirmTwoFactorRequest $request): \Illuminate\Http\JsonResponse
    {
        $user = $request->user();

        return response()->json([
            'message' => \App\Enums\TwoFactorStatus::SUCCESS->value,
            'recoveryCodes' => $user->getRecoveryCodes(),
            'status' => \App\Enums\TwoFactorStatus::ENABLED->value,
        ]);
    }

What this does
- Verifies the 6‑digit code the user typed from their authenticator app.
- If valid, enables 2FA on the account and returns recovery codes the user should save (these are one‑time use backup codes).

Tip: Treat recovery codes like passwords — show them once and encourage users to store them safely.

Enum for clarity

    enum TwoFactorStatus: string
    {
        case ENABLED = 'enabled';
        case IN_PROGRESS = 'in_progress';
        case DISABLED = 'disabled';
        case TWO_FA_REQUIRED = '2fa_required';
        case SUCCESS = 'success';
    }

Why an enum?
- Keeps magic strings out of your controllers and responses.
- Easier to change in one place and keep the API consistent.

Recovery codes endpoint (optional but recommended)

    public function showRecoveryCodes(\Illuminate\Http\Request $request): \Illuminate\Http\JsonResponse
    {
        $recoveryCodes = $request->user()->generateRecoveryCodes();

        return response()->json([
            'message' => \App\Enums\TwoFactorStatus::SUCCESS->value,
            'recoveryCodes' => $recoveryCodes,
        ]);
    }

What this does
- Generates a fresh set of recovery codes on demand (helpful if the user lost them). Depending on your policy, you may want to limit how often users can regenerate.

Example response

        {
            "message": "success",
            "recoveryCodes": ["6Z9K-1ABC-XY7Q", "..." ]
        }

Disable 2FA

    public function disableTwoFactorAuth(\App\Http\Requests\Api\V1\Auth\DisableTwoFactorRequest $request): \Illuminate\Http\JsonResponse
    {
        $request->user()->disableTwoFactorAuth();
        return response()->json([
            'message' => 'Two-Factor Authentication has been disabled!',
            'status' => \App\Enums\TwoFactorStatus::DISABLED->value,
        ]);
    }

What this does
- Turns off 2FA for the user after passing validation in the DisableTwoFactorRequest (e.g., ask for current password).

Example response

        {
            "message": "Two-Factor Authentication has been disabled!",
            "status": "disabled"
        }

---

2) Enforce 2FA at login (the secure way)

Here’s the flow that feels good for APIs:
1) User submits email/password.
2) If 2FA is disabled → return a Sanctum token like normal.
3) If 2FA is enabled → create a short‑lived, encrypted session marker and return 2fa_required.
4) User submits the 6‑digit code to a dedicated endpoint.
5) If the code is valid → clear the marker and issue the Sanctum token.

Controller: login (excerpt)

    public function login(LoginUserRequest $request): \Illuminate\Http\JsonResponse
    {
        if (session('2fa_login')) {
            session()->forget('2fa_login');
        }

        $user = $this->loginUserService->attemptLogin($request->email, $request->password);

        \App\Events\UserLogin::dispatchIf(!$user->timezone, $user);

        if ($this->loginUserService->handleTwoFactor($user)) {
            return response()->json([
                'message' => 'Two-factor authentication is enabled. Please provide the verification code.',
                'status' => \App\Enums\TwoFactorStatus::TWO_FA_REQUIRED->value,
            ], 200);
        }

        return response()->json([
            'message' => 'User authenticated successfully',
            'user' => new \App\Http\Resources\UsersResource($user),
            'status' => \App\Enums\TwoFactorStatus::SUCCESS->value,
            'access_token' => $user->createToken(
                'Api Token for ' . $user->email,
                ['*'],
                now()->addMonth()
            )->plainTextToken,
        ], 200);
    }

What this does
- Clears any stale 2FA marker.
- Authenticates email/password. If the user has 2FA enabled, we don’t issue a token yet — we return a two‑step prompt (status two_fa_required) and stash a short‑lived, encrypted marker in the session.
- If 2FA is not enabled, we proceed normally and issue a Sanctum token.

Service: only store what you need (no plaintext password)

    public function handleTwoFactor($user): bool
    {
        if ($user->hasTwoFactorEnabled()) {
            session(['2fa_login' => encrypt([
                'user_id' => $user->id,
                'expires_at' => now()->addMinutes(5),
            ])]);
            return true;
        }
        return false;
    }

Why this matters
- Only the minimal info (user_id + expiry) is kept server‑side in an encrypted session entry. Don’t store plaintext passwords — not needed and riskier.
- The 5‑minute expiry protects against abandoned flows.

Confirm the login with the OTP

TwoFactorLoginRequest validates a 6‑digit code and checks the short‑lived session marker. On success, it authenticates the request’s user for issuing a token. Sketch of the rules:

    public function rules(): array
    {
        return [
            'code' => ['required', 'digits:6'],
        ];
    }

    public function withValidator($validator): void
    {
        $validator->after(function ($validator) {
            $this->validateTwoFactorSession($validator, $this->input('code'));
        });
    }

What this does
- Ensures the 6‑digit code is present and looks right.
- Then runs a custom check to validate the encrypted 2FA session marker (exists, not expired) and the code itself via the package helpers.
- Consider adding route throttling (e.g., throttle:6,1) to slow down brute force attempts.

Controller: finalize and issue token

    public function twoFactorLogin(\App\Http\Requests\Api\V1\Auth\TwoFactorLoginRequest $request): \Illuminate\Http\JsonResponse
    {
        $user = $request->user();

        // Clear the 2FA session after successful login
        session()->forget('2fa_login');

        return response()->json([
            'message' => 'User authenticated successfully',
            'user' => new \App\Http\Resources\UsersResource($user),
            'status' => \App\Enums\TwoFactorStatus::SUCCESS->value,
            'access_token' => $user->createToken(
                'Api Token for ' . $user->email,
                ['*'],
                now()->addMonth()
            )->plainTextToken,
        ], 200);
    }

What this does
- On success, clears the 2FA session marker and finally issues a first‑class API token via Sanctum.
- From the client’s perspective, this is step two of login.

Routes

    Route::controller(\App\Http\Controllers\Api\TwoFactorController::class)
        ->prefix('twofactor')
        ->name('twofactor.')
        ->group(function () {
            Route::post('setup', 'prepareTwoFactor')->name('setup');
            Route::post('confirm', 'confirmTwoFactor')->name('confirm');
            Route::get('fetch-user', 'getUserStatus')->name('fetch-user');
            Route::get('recovery-codes', 'showRecoveryCodes')->middleware('2fa.enabled')->name('recovery-codes');
            Route::delete('disable', 'disableTwoFactorAuth')->name('disable');
            Route::post('login-confirm', 'twoFactorLogin')
                ->name('login-confirm')
                ->middleware('throttle:6,1')
                ->withoutMiddleware(['auth:sanctum']);
        });

Why this setup
- recovery-codes is protected with the package middleware so only users with 2FA enabled can call it.
- login-confirm is throttled and intentionally bypasses auth:sanctum because the user isn’t fully authenticated yet; they’re proving possession of the OTP.

Practical cURL examples (for testing)

1) Prepare 2FA (logged-in user)

        curl -X POST https://localhost:8000/api/twofactor/setup \
            -H "Authorization: Bearer <token>" \
            -H "Content-Type: application/json" \
            -d '{"password": "<current_password>"}'

2) Confirm 2FA

        curl -X POST https://localhost:8000/api/twofactor/confirm \
            -H "Authorization: Bearer <token>" \
            -H "Content-Type: application/json" \
            -d '{"code": "123456"}'

3) Login (step 1)

        curl -X POST https://localhost:8000/api/login \
            -H "Content-Type: application/json" \
            -d '{"email": "john@example.com", "password": "secret"}'

    - If 2FA enabled, you’ll get:

        { "message": "Two-factor authentication is enabled...", "status": "2fa_required" }

4) Login confirm (step 2)

        curl -X POST https://localhost:8000/api/twofactor/login-confirm \
            -H "Content-Type: application/json" \
            -d '{"code": "123456"}'

    - On success you’ll get an access_token you can use in subsequent requests.

Notes that saved me time
- Throttle the login-confirm endpoint to slow down brute force on the OTP.
- Keep the 2FA session marker short‑lived (I use 5 minutes) and encrypted. Don’t stash plaintext passwords.
- If codes are always “invalid,” check server time sync and the user’s device time.
- If the session marker isn’t found, confirm your session driver and CORS/cookies configuration for your SPA.

Extra safeguards
- Use HTTPS everywhere — OTPs shouldn’t travel over plain HTTP.
- Don’t log OTP codes or the otpauth URI/secret in application logs.
- Consider notifying users when 2FA is enabled/disabled on their account.

Should this be one post or two?
I kept everything in one place because the whole story is pretty short once you see it. If you prefer to break it up, a natural split is:
- Part 1: Setup & confirm 2FA (+ recovery codes, disable)
- Part 2: Secure login with 2FA (session handoff, request validation, token issuance)

That’s it. If you want to see this in a real codebase, check the Profresh repository. If you run into something odd, ping me — I probably tripped over the same thing.

