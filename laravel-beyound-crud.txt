Scaling down models
 If our goal is to keep model classes reasonably small—small enough to be
 able to understand them by simply opening their file—we need to move some
 more things around. Ideally, we only want to keep the data read from the
database,simpleaccessorsforstuffwecan'tcalculatebeforehand,casts,
 andrelations.
 Other responsibilities should bemoved to other classes.One example is
 query scopes.We could easily move them to dedicated query builder classes.
 Believe it or not,query builder classes are actually the normal way of using
 Eloquent ;scopes are simply syntactic sugar on top of them.This is what a
 query builder class might look like.

 namespaceDomain\Invoices\QueryBuilders;
 use Domain\Invoices\States\Paid;
 use Illuminate\Database\Eloquent\Builder;
 class InvoiceQueryBuilder extends Builder
 {
 public function wherePaid(): self
 {
 return $this->whereState('status', Paid::class);
 }
 }

 Next up,we override the new Eloquent Builder method in our model and return
 our custom class.Laravel will use it from now on.

 
 namespaceDomain\Invoices\Models;
 use Domain\Invoices\QueryBuilders\InvoiceQueryBuilder;
 class Invoice extends Model
 {
 public function new EloquentBuilder($query):InvoiceQueryBuilder
 {
 return new InvoiceQueryBuilder($query);
 }
 }


 This is what I meant by embracing the framework: you don't need to introduce
 new patterns like repositories per se; you can build upon what Laravel
 provides. With some thought, we strike the perfect balance between using
 the commodities provided by the framework and preventing our code from
 growing too large in specific places.
 Using this mindset, we can also provide custom collection classes for
 relations. Laravel has great collection support, though you often end up with
 long chains of collection functions either in the model or in the application
 layer. This again isn't ideal, and luckily Laravel provides us with the needed
 hooks to bundle collection logic into a dedicated class.